## Bomblab

挺有意思的,不过对于我们这些自学的而言,没了 bomb 的威慑,感觉还是差点意思.

先说说怎么避免 explosion.

简单的方法,只需要  `b explode_bomb` 就行了.

复杂一点,我们知道 gdb 可以使用 `command <breakpoint number>` 设置到达断点之后运行的指令.`jump` 可以通过函数名/label/行号/地址跳转(加一个*),这样你可以一旦进入 explode_bomb 就跳到函数结尾.然后你把这些指令输入到 .gdbinit 就行了.

### phase_1

根据函数名(string_not_equal),不难发现,这段代码在比较我们输入的字符串跟地址 0x402400 里存的字符串是否相同.

使用 `x/s <address>` 可以把当前数据当成 C 风格字符串查看,我们知道答案是 `Border relations with Canada have never been better.`

### phase_2

这个部分,感觉最复杂的是看懂 read_six_numbers 是怎么工作的.

经过研究,发现它把六个数读到 %rsp 所存地址开头的 6*4 bytes 当中.并且要求 *(%rsp) = 1

之后是一个循环,每次都要,上一个位置的值的两倍跟当前位相同.所以这个是等比数列.

### phase_3

这个一眼发现是 switch,整个函数的流程就是你输入两个数(__isoc99_sscanf 之后 %eax 存的是它成功读入的数,这个数不会超过它指定的范围所能做到的最大值[%rdx,%rcx]),然后第一个数进入 switch,你需要第二个数跟第一个数 switch 之后的结果相等.

这个并不难,一方面,你可以去看一眼 0x402470 及后面存的是什么地址.

另一方面,你也可以读一下 asm 里的存在 .rodata 的表.

选择一个你喜欢的数作为第一个输入,找到对应的第二个输入就行了.

### phase_4

大眼一扫，读进来两个数，然后调用 func4 最后会得到一个 eax，希望 eax=0，这个过程只跟第一个输入有关。然后第二个输入只需要是 0 就行了。所以我们要仔细看一看 func4.

你把 func4 改写成 C++ 的形式，稍微加上一点灵感（和对 lecturer 良心的信任）可以发现这个是一个二分，然后 eax 事实上是在记录我们二分的路径（如果是左就写一个 0，否则写一个 1）。

那我们最后想让 eax 是 0，就是一路往左走。二分的范围是 [0,15]，所以我们第一个值整成 0 就行了。

### phase_5

你发现它读入一个字符串，然后是一个循环，对每个字符分别操作。

操作大概就是，读取这个字符的最后 4bits，然后放到一个写好的表里去查找得到对应的字符，最后要让变换后的字符串和一个给定的字符串（`flyers`）相同。

那你只需要把这个操作逆过来做一遍就行了。

注意读入字符串最后必须有一个回车。

### phase_6

phase_6 咋这么长？？？